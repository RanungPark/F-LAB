# CORS

자바스크리트에서의 요청은 브라우저가 하나의 서버 연결만 허용되도록 설정되엉 있기 때문에 기본적으로 서로 다른 도메인에 대한 요청을 보안상 제한한다.

### 출처(Origin)

- Protocol과 Host, Port까지 합친 URL을 의미한다

### 동일 출처 정책(Same-Origin Policy)

- XMLHttpRequest, Fetch API는 기본적으로 Same-Origin 정책을 따른다.
- 동일한 출처에 대한 정책을 말한다 즉 동일한 출처에서만 리소스를 공유할 수 있다.

서로 다른 출처의 리소스를 받는 환경은 해커가 CSRF나XSS와 같은 공격을 진행할 수 있기 때문에 보안성 좋지 않으므로 동일한 출처에서만 리소스를 공유하는 것이다. 

웹 브라우저는 HTTP 요청에 대해서 어떤 요청을 하느냐에 따라 각기 다른 특징을 가진다.

`<img>,<video>,<script>,<link>` 태그등 기본적으로 Cross-Origin 정책을 지원한다.

### 교차 출처 리소스 공유(CORS)

- 출처를 비교하는 행위는 브라우저에서 진행된다. 즉 브라우저가 정책을 차단한다.
- 교차 출처 리소스 공유(CORS)는 다른 출처의 리소스 공유에 대한 허용 또는 비허용 정책이다
    - 즉 SOP 정책을 위반해도 CORS 정책을 따르면 다른 출처의 리소스라도 허용해준다는 말이다.

**브라우저 CORS 기본 동작**

1. 클라이언트에서 HTTP요청의 헤더에 Origin 이라는 필드에 출처를 함께 담아서 서버에 요청을 보낸다.
2. 서버는 응답 헤더에 Access-Control-Allow-Origin이라는 필드에 ‘리소스를 접근 하는 것이 허용된 출처’를 넣어 응답한다.
3. 브라우저에서는 클라이언트에서 보낸 요청의 Origin필드와 서버에서 보낸 응답의 Access-Control-Allow-Origin과 비교하여 서로 같다면 출처가 유효함으로 문제없이 가져오고 다르다면 CORS에러가 발생한다.

### 예비 요청(Preflight Reuest)

브라우저는 요청을 보낼 때 먼저 예비 요청을 보내고 서버와 잘 통신되는지 확인후 본 요청을 보낸다.

Preflight는 HTTP 메소드를 GET이나 POST가 아닌 **OPTIONS**이라는 요청이 사용 된다.

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/ab9ad307-d5d2-41b6-b830-c16abd5b1e06"  width="500" height="400"/>

1. 자바스크립트에서 서버에 요청을 보낸다.
2. 브라우저는 서버로 HTTP OPTIONS 메서드로 예비 요청(Preflight)를 먼저 보낸다. 이때 헤더에 밑에와 같은 필드를 넣는다.
    1. Origin필드에 브라우저 Origin을 설정한다.
    2. Access-Control-Request-Method에 본 요청에서 사용할 메서드를 설정한다.
    3. Access-Control-Request-Headers에 본 요청에 사용할 헤더를 설정한다.
3. 서버는 예비 요청에 대한 응답을 어떤 것을 허용할지 비허용 할지 헤더에 정보를 담아 브라우저에 보낸다.(서버가 허용해준 애들을 본 요청에서 보낼 수 있다.)
    1. Access-Control-Allow-Origin 필드에는 Origin 목록을 설정한다.
    2. Access-Control-Allow-Methods 필드에 메서드들의 목록을 설정한다.
    3. Access-Control-Allow-Headers 필드에는 헤더들의 목록을 설정한다.
    4. Access-Contorl-Max-Age 필드에는 Preflight가 브라우저에 캐시 될 수 있는 시간을 초 단위로 설정한다.
4. 이후 브라우저가 보낸 요청과 서버가 보낸 응답을 비교 후 요청이 안전하다면 본 요청을 보낸다.
5. 서버가 본 요청을 응답하면 자바스크립트가 응답을 받을 수 있다.

**예비 요청의 문제점**

실제 요청에 걸리는 시간이 늘어나게 된다.

API수가 많을 수록 요청은 배가 된다. 이를 브라우저 캐시를 이용해 Preflight요청을 캐싱 시켜 최적화 시킬 수 있다.

### 단순 요청(Simple Request)

예비 요청인 Preflight를 생략하고 바로 서버에 직행으로 요청을 보낸다.

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/81290d0a-61aa-49b1-9df5-5282b98a96d4"  width="500" height="400"/>

**대부분의 API요청은 예비 요청으로 이루어진다.**

### 인증된 요청(Credentialed Request)

클라이언트가 서버에게 **자격 인증 정보**를 실어 요청할 때 사용된다.

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/3cbedd88-8612-43c1-a39c-b23cff8ed88f"  width="500" height="400"/>

자격 인증 정보란

- 세션 ID가 저장되어 있는 **쿠키** 혹은 **Authorization 헤더**에 설정하는 **토큰**값을 말한다.

서버는 응답 헤더에 와이드 카드(*)가 아닌 분명한 Origin으로 설정해야 한다. 그렇지 않으면 CORS정책에 의해 응답이 거부된다.

인증된 요청 또한 예비 요청이 일어난다.

### 프록시 사이트 이용하기

프록시(Proxy)는 클라이언트와 서버 중간에 위치하여 통신을 대신 수행하는 것을 프록시라 하며 그 중계 기능을 하는 주체를 프록시 서버라고 한다.

**포워드 프록시**


<img src="https://github.com/RanungPark/F-LAB/assets/104816866/93aab53e-c4a4-45a0-8324-19c58d88b7ee"  width="500" height="400"/>

- 일반적으로 말하는 프록시이며 클라이언트와 서버 사이에 위치하여 요청을 중계하고 요청과 응답은 프록시 서버를 거친다.
- 클라이언트를 감춘

**리버스 프록시**

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/c66214ba-5ca8-4ef2-963e-3a47cc2df8b9"  width="500" height="400"/>

- 포워드 프록시와 달리 서버들이 내부망으로 구성되며 프록시에게 연결을 허용한다. 즉 서버를 위한 보안 채널을 구축한다.
- 클라이언트가 서버에 접근하는 것이 불가능하다. 서버를 감추는 효과가 있다.

프록시의 장점

- 개인정보를 보호 할 수 있다.
    - 프록시 서버를 사용하면 서버측에서 나의 IP가 아닌 프록시 서버의 IP를 보게 되어 IP를 숨길 수 있다.
- 캐시를 사용해서 속도를 향상시킨다.
    - 같은 요청이 들어오면 캐시 자원을 반환한다. 서비스 속도를 높이고 대역폭도 줄여준다
    - 대여폭이란 정보를 전송할 때의 전송량을 말한다.
- 로그를 기록 관리한다
    - 프록시 서버에겐 클라이언트의 기록이 남는다 이는 어떤 IP가 얼마나 접속 하였는지 알 수 있고 특정 IP가 방할 수 있는 웹사이트를 제한 할 수 있다.