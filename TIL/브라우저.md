### browser elements
사용자 인터페이스: 사용자 인터페이스는 주소 바, 뒤로가기 앞으로 가기 버튼, 홈버튼, 새로고침등 요청한 페이지를 보여주는 창 외에 사용자가 컨트롤 할 수 있는 부분을 말한다.

브라우저 엔진: 브라우저 엔진은 사용자 인터페이스와 렌더링 엔진 사이에서 동작을 제어하며, 자료 저장소에 캐된 페이지가 있는지 찾아 있다면 해당 페이지를 렌더링 엔진에 보낸다.

자료저장소: 자주 방문하는 URI를 캐싱해 둔다.

렌더링 엔진: 요청한 URI를 브라우저 엔진에게 받아서 server에게 요청한다(자료저장소에 없을 경우)

server로 부터 받은 URI에 해당하는 HTML, CSS를 받아 파싱하고 자바스크립트는 자바스크립트 엔진에 보낸다. 파싱후 렌더링 한다.

네트워크: 렌더링 엔진으로 부터 HTTP 요청을 받아서 서버와 네트워크 처리 후 응답을 전달한다.

자바스크립트 엔진: 자바스크립트를 파싱한다.

UI 백엔드: 렌더트리를 브라우저에 그리는 역할을 한다.

![image](https://github.com/RanungPark/F-LAB/assets/104816866/7ada2dbd-7b7a-46a5-ba3b-62c12048965b)### browser elements

### 렌더링 과정

1. 사용자가 사용자 인터페이스에 있는 주소창에 URI를 입력하면 브라우저 엔진에 전달한다.
2. 브라우저엔진은 전달받은 URI를 자료저장소에서 검색하고 해당 자료를 쿠키로 저장했다면 그자료를 렌더링 엔진에 전달한다
3. 렌더링 엔진은 브라우저엔진에게 전달 받은 자료를(HTML, CSS, image등) 분석을 한다.
4. 렌더링 엔진은 통신 레이어에 URI에 추가적인 데이터가 있다면 요청하고 응답을 기다린다.
5. 응답받은 HTML, CSS를 렌더링 엔진에서 파싱한다.
6. HTML 파싱중 script태그를 만나면 파싱을 중단하고 자바스크립트 엔진에게 권한을 넘겨 자바스크립트를 파싱한다
7. 파싱 결과를 렌더링 엔진에게 전달하여 HTML  DOM을 조작한다
8. DOM과 CSSOM을 어파치먼트 하여 렌더트리를 만든다
9. 이때 렌더트리에는 display:none이나 화면에 적용되지 않는 노드들은 포함하지 않는다
10. 렌더트리를 구축하면 레이아웃 단계에서 박스모델을 기반으로 크기와 위치를 정한다
11. 페인트 단계에서 폰트,색상등을 지정한다
12. 페인트 단계가 끝나면 컴포지트 단계를 거쳐 브라우저에 렌더링을 한다.

### 최적화 방법

리플로우와 리페인트는 CPU에서 처리하며 컴포지트와 레이어는 GPU에서 처리한다. CPU는 GPU보다 처리 비용이 비싸기 때문에 컴포지트에서 처리하여도 같은 동작이라면 리플로우와 리페인트를 발생시키지 않는 것이 좋다

대표적으로 transform을 진행한다면 새로운 layer가 생겨나기 때문에 리플로우와 리페인트가 발생하지 않고 컴포지트단계에서 실행된다.

또한 display:none을 하여 스타일을 변경하고 다시 display:block한다면 여러번의 리플로우가 발생하지 않고 한번에 발생하게 된다.

애니메이션을 작성할 때는 position이 relative라면 주변 노드의 위치에 영향을 줄 수 있기 때문에 absolute로 바꾸어 진행하여야한다.

또한 리플로우를 발생시키는 코드를 JS에서 작성한다면 따로따로 작성하는 것이 아니라 한곳에 모아서 작성하는 것이 좋다 리플로우가 발생한다면 렌더큐에 저장되었다가 실행하는데 렌더큐는 60프레임으로 동작한다 따로 작성하였다면 렌더큐에서 연속적으로 빠져나가지 않을 수 있기 때문에 한곳에 작성하는 방법이 좋을 수 있다.