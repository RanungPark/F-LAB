## 자바스크립트 메모리 구조

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/74fbc2b0-4406-419b-9f4d-f21f6e0820cd"  width="500" height="400"/>

**자바스크립트는 스택과 힙 두가지 영역을 사용하여 변수나 함수 생성될 때 자동으로 메모리를 할당하고, 더 이상 사용하지 않을 때 가비지 컬렉터를 통해 메모리를 해제한다**

### code area

- 실행할 자바스크립트 코드를 저장한다

### 콜 스택

- 실행 컨텍스트의 정보를 저장한다
- 실행 컨텍스트는 변수와 함수선언 this를 저장한다
- 실행컨텍스트 안에 기본 타입이 저장된다. (LexicalEnvironment 안에 저장이 된다)
- 그렇기 때문에 콜 스택에 기본 타입이 저장된다고 생각할 수 있다. (식별자와 기본 타입의 데이터가 콜스택에 저장된다.)
- **자바스크립트 엔진의 메모리에는 콜 스택이 하나이므로 싱글스레드이다.**

### 메모리 힙

- 참조 데이터가 저장된다.
- 참조 타입은 동적으로 크기가 변하기 때문에 메모리 힙에서 관리하는 것이 메모리 효율측면에서 우수하다
- 메모리의 할당이 이루어지는 곳이다
- 이때 참조 데이터의 식별자는 콜 스택에 저장된다

### let 과 const

let은 변수의 값에 있는 데이터가 저장된 메모리 주소의 변경을 허락한다.

const는 변수의 값에 있는 데이터가 저장된 메모리 주소의 주소를 변경하지 않는다.

### 가비지 컬렉터(GC)

- **참조 카운트 기반:**
  - 객체가 생성될 때마다 참조 카운트를 증가시킵니다.
  - 객체의 참조가 끝날 때마다 참조 카운트를 감소시킵니다.
  - 참조 카운트가 0이 되면 해당 객체는 더 이상 사용되지 않으므로 가비지 컬렉터에 의해 회수됩니다.
- **Mark-and-Sweep (표시 및 삭제):**
  - 루트 객체에서부터 시작하여 도달 가능한 모든 객체를 표시(mark)합니다.
  - 표시되지 않은 객체는 도달 불가능한 것으로 간주하고, 해당 객체의 메모리를 해제합니다.

### 스코프

**함수 스코프**

- var키워드를 통해 서언된 변수는 함수 스코프를 가진다 함수 외에 지역에서 선언된다면 전역 객체의 프로퍼티로 인식된다.

**블록 스코프**

- const, let 키워드를 통해 서언된 변수는 블록 스코프를 가진다. {}문 안에 작성되었다면 {}문 안에서만이 변수의 유효범위이다.
- const, let 키워드 또한 호이스팅이 되지만 TDZ(일시적인 사각지대)로 인하여 스코프 시작 시점 부터 초기화 시점까지 변수에 접근할 수 없다.

**렉시컬 스코프**

- 함수는 렉시컬 스코프를 가진다
- 함수는 정의된 위치(선언된 위치)에 따라 스코프가 결정된다.
- 함수를 호출한 곳에서 스코프가 결정되지 않는다(함수가 호출하는 곳에 따라 스코프가 결정된다면 동적 스코프이다)

### 컴파일과 인터프리터

**컴파일**

- 프로그램 전체를 한번에 스캔 및 컴파일 하여 기계어로 번역

**인터프리터**

- 한 번에 한 문장씩 번역

**자바스크립트는 초기에는 인터프리터 언어로 만들어 졌으며 V8엔진은 컴파일 방식과 혼합하여 사용한다**

---

[https://sasca37.tistory.com/302#article-1-1--javascript-엔진-(인터프리터-vs-컴파일)](<https://sasca37.tistory.com/302#article-1-1--javascript-%EC%97%94%EC%A7%84-(%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-vs-%EC%BB%B4%ED%8C%8C%EC%9D%BC)>)https://charming-kyu.tistory.com/19

[https://velog.io/@code-bebop/JS-메모리-구조](https://velog.io/@code-bebop/JS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
