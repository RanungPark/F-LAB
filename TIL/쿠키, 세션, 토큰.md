## 인증/ 인가

- **인증**이란 식별 가능한 정보로 사용자가 누구인지 확인하는 절차이다.
    - 로그인을 통해 사용자를 식별하는 절차
- **인가**란 인증된 사용자가 특정 자원에 접근할 수 있는지 권한을 확인하는 절차이다.
    - 로그인한 사용자가 다른 사용자의 게시물을 수정할 수 없는 것은 인가를 통과하지 못해서 이다

## 쿠키(Cookie)

쿠키는 Key-Value 형식의 **문자열**이다.

**만료 기간**이 있는 클라이언트 단에 저장하는 작은 텍스트 파일이다.

서버를 통해 클라이언트의 브라우저에 설치되는 작은 텍스트 파일이다.

→ 즉 서버가 생성하여 클라이언트에 저장한다.

쿠기의 보안적인 이유로 클라이언트에는 민감한 정보를 저장하지 않는다.

### **동작 원리**

1. 클라이언트가 서버에 HTTP 요청을 보냄
2. 서버가 HTTP 응답시 set-cookie를 통해 쿠키를 생성하여 전달
3. 클라이언트는 매 요청에 HTTP Header에 쿠키를 담아서 전송
4. 만료 기간 전이라면 쿠키는 브라우저에 저장하여 요청 시 사용하고 만료가 되었다면 클라이언트가 새로 서버에 요청하여 쿠키를 발급 받음

### 장점

대부분의 브라우저에서 지원한다.

XSS로부터 안전하다.

### **단점**

- 보안에 취약하다.
- 용량이 제한적이다.
- 브라우저간 공유가 불가능하다.

## 웹 스토리지

클라이언트에 저장만 할 뿐 서버에 전송되지는 않는다.

### **로컬 스토리지**

- 브라우저 자체에 **반 영구적**으로 데이터를 저장하고 브라우저를 종료해 데이터가 유지된다.

### **세션 스토리지**

- **탭 윈도우 단위**로 생성되고 탭 윈도우를 답을 때 데이터가 삭제 된다.

### 장점

- 서버에 불필요한 데이터를 저장하지 않는다.
- 용량이 넉넉하다.
- 자바스크립트의 모든 데이터 타입이 저장 가능하다.

### 단점

- HTML5를 지원하는 브라우저에서만 사용 가능하다
- XSS로부터 위험하다.

## 세션

민감한 인증 정보를 브라우저가 아닌 서버 측에 저장하고 관리한다.

세션 객체는 Key에 해당하는 세션 ID와 이에 대응하는 Value로 구성되어있다.

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/269cd58f-9884-4275-b9bc-3376333006c1"  width="500" height="400"/>

1. 클라이언트가 서버에 로그인
2. ID/ PW 인증후, 사용자 식별하는 특정 유니크한 세션ID를 만들어 저장소에 저장
3. 세션 ID를 클라이언트에 반환
4. 이후 인가 작업 때마다 세션 ID를 쿠키에 담아서 서버에 전달
5. 서버에서 세션 ID가 세션 저장소에 유효한지 확인
6. 유효하다면 인증 완료후 적절한 응답, 없다면 401 에러

### 문제점

- 세션 ID또는 쿠키를 탈취 당할시 세션 저장소를 지우면 해결할 수 있지만 탈취당하지 않은 정상적인 사용자도 재 인증을 할 수도 있다.
- HTTP의 stateless한 특징에 위배된다.
    - 이 문제는 확장성에 문제가 있다.
    - 세션 저장소를 별도로 외부에 두는 방법으로 해결할 수 있으며 Redis가 가장 많이 사용된다.

## 토큰

클라이언트가 서버에 접속하면 서버는 클라이언트에게 인증되었다는 토큰을 부여한다.

클라이언트는 이 토큰을 헤더에 심어서 서버에 전송한다.

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/b1ce1d39-aae8-4304-9cc4-e9a6d7d4cb94"  width="500" height="400"/>

1. 클라이언트가 서버에 로그인을 한다
2. 유효한 ID/ PW라면 Access token & Refresh token을 발급한다.
3. 클라이언트는 전달 받은 토큰들은 localStorage에 저장한다.(상황에 따라 저장위치는 변할 수 있음)
4. 클라이언트는 헤더에 Access token을 담아 서버에 요청한다.
5. 서버에는 Access token을 검증하고, 응답을 클라이언트에 보낸다.
6. Access token이 유효하지 않다면 Refersh token으로 Access token을 재발급한 뒤, 재발급하 Access token을 리턴해준다.

### **문제점**

- 토큰 자체 데이터 길이가 길어 인증 요청이 많아지면 네트워크 부하가 생길 수 있다.
- Payload 자체는 암호화되지 않기 때문에 중요한 정보를 담을 수 없다
- 토큰을 탈취 당하면 대처하기 어렵다

## JWT

인증에 필요한 정보들을 암호화 시킨 JSON 토큰

Base64 URL로 인코딩하여 직렬화를 시켰다.

<img src="https://github.com/RanungPark/F-LAB/assets/104816866/af9224b0-84bd-4398-9b75-a2ba7c607f3b"  width="500" height="400"/>

### 헤더(Header)

- typ: 토큰의 타입
- alg: 해싱 알고리즘

### 내용(Payload)

- 토큰에 담을 서버와 클라이언트가 주고받으며 사용될 정보를 저장
- 키와 벨류로 이루어진 한 쌍의 정보를 클레임이라고 한다.

**Registered claims: 미리 정의된 클레임**

- iss (토큰 발행자)
- exp (토큰 만료 시간)
- aud (토큰 대상자)
- sub (토큰 제목)
- iat (토큰 발행 시간)
- jti (JWT ID)

**Public claims: 사용자가 정의할 수 있는 클레임 공개용 정보 전달을 위해 사용 ture 표기**

**Private claims: 서버와 클라이언트 협의 하에 사용되는 클레임 이름**

### 서명(Signature)

토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 교유한 암호화 코드

헤더+페이로드+ 서버가 갖고 있는 유일한 key 값을 헤더에서 정의한 alg로 암화화 해둔다

토큰은 정보보호가 아닌 위조를 방지하는 것이 목적이다.

서버는 토큰 안에 들어있는 정보가 무엇인지 아는 것이 중요한 것이 아니라 해당 토큰이 유효한 토큰인지 확인하는 것이 중요하다.

### 문제점

토큰을 탈취 당했을 때 대처하기가 어렵다

**Access Token:** 클라이언트가 갖고 있는 실제로 유저의 정보가 담긴 토큰, 클라이언트가 지니고 있음

**Refresh Token:** 새로운 Access Token을 발급해주기 위해 사용하는 토큰, 보통 데이터베이스에 같이 기록

[https://inpa.tistory.com/entry/WEB-📚-JWTjson-web-token-란-💯-정리](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)

[https://velog.io/@ddangle/Session세션과-Token토큰의-차이는](https://velog.io/@ddangle/Session%EC%84%B8%EC%85%98%EA%B3%BC-Token%ED%86%A0%ED%81%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94)