### **자바스크립트에서 this 바인딩이 예측과 다르게 동작하는 경우와 그 원인은 무엇인가요?**

객체 내에서 함수를 실행할 때 안에서의 this는 전역을 가리킨다.

또는 같은 함수더라도 객체의 메서드로써의 함수호출과 일반 함수 호출이 가리키는 this가 다르기 때문에 예측하기 어렵게 동작한다.

### strict mode에서 this 바인딩이 어떻게 달라지나요?

strict mode에서 this는 전역을 바라보지 않고 undefined를 호출한다.

### 화살표 함수에서의 this는 어떻게 바인딩되나요?

화살표 함수의 실행 컨텍스트는 this바인딩이 존재하지 않는다. 때문에 화살표 함수 내부에서의 this는 가장 가까운 상위 실행 컨텍스트의 this를 가리킨다.

### 생성자 함수에서 this에 바인딩되는 객체는 무엇인가요?

생성자 함수에서 this는 new를 통해 생성된 인스턴스 객체를 가리킨다.

### bind 메소드를 사용하여 this 바인딩을 변경하는 방법을 설명해주세요.

bind 메소드를 사용하면 bind 메소드의 인자에 있는 객체를 바인딩한 함수를 새롭게 만들어 반환한다.

### **브라우저의 CORS 정책이란 무엇이며, 어떤 문제를 해결하기 위한 것인가요?**

교차 출처 리소스 공유 정책이라고 해석할 수 있다. 다른 출처로부터 리소스에 대한 요청하는 것을 제한하여 웹 보안을 강화한다. 이를 통해 잠재적으로 해로운 사이트에서 사용자의 개인 정보를 탈취하는 공격을 방지하기 위해 사용된다.

### CORS 정책 위반 시 브라우저는 어떤 에러를 반환하나요?

1. Preflight 에러: 브라우저가 실제 요청을 보내기 전에 OPTIONS 메서드를 사용하여 사전 요청(preflight request)을 보내는 경우가 있다. 이 사전 요청은 서버가 클라이언트의 요청을 수락할 수 있는지 확인하기 위한 것이다. 서버가 CORS 정책에 위반된 요청에 대해 허용하지 않는다면, 브라우저는 Preflight 에러를 반환한다.
2. 실제 요청 에러: Preflight 요청이 성공적으로 완료된 후에도 서버에서 실제 요청에 대한 응답이 CORS 정책을 위반하는 경우, 브라우저는 해당 실제 요청에 대한 에러를 반환하나. 이는 일반적으로 브라우저의 개발자 도구 또는 네트워크 탭에서 확인할 수 있다.

### 프리플라이트 요청이란 무엇이며, 언제 필요한가요?

프리플라이트 요청은 CORS에서 실제 요청을 보내기 전에 프리플라이트 요청을 사용하여 서버에 사전 요청을 보내는 것이다.

**필요한 경우**

- 실제 요청 메서드가 `GET`, `HEAD`, `POST`, `PUT`, `DELETE` 외의 메서드인 경우
- 실제 요청 헤더에 `Content-Type`, `Authorization` 등의 특정 헤더가 포함된 경우
- 실제 요청에서 자격 증명(쿠키, HTTP 기본 인증 등)을 사용하는 경우

### CORS를 해결하기 위한 서버 측 구현 방법은 무엇이 있나요?

**헤더 설정**

- `Access-Control-Allow-Origin` 헤더: 요청 허용 도메인 설정
- `Access-Control-Allow-Methods`: 허용 HTTP 메서드 설정 (GET, POST, PUT, DELETE 등)
- `Access-Control-Allow-Headers`: 허용 HTTP 헤더 설정 (Content-Type, Authorization 등)
- `Access-Control-Allow-Credentials`: 자격 증명 허용 설정 (쿠키, HTTP 기본 인증 등)
- `Access-Control-Max-Age`: 프리플라이트 요청 캐싱 시간 설정

**프록시 서버 사용**

### 웹 애플리케이션에서 CORS 문제를 회피하는 프록시 서버 구축 방법을 설명해주세요.

**프록시란?**

프록시는 서버 또는 응용프로그램으로 클라이언트와 서버 사이의 중개자 역할을 한다.

1. **프록시 서버 소프트웨어 선택:** Nginx, Apache, HAProxy 등 다양한 프록시 서버 소프트웨어가 존재한다.
2. **프록시 서버 설정:**
    - 클라이언트 요청을 받는 포트 설정
    - 백엔드 서버 주소 설정
    - CORS 헤더 설정 (`Access-Control-Allow-Origin` 등)
3. **프록시 서버 실행:** 설정에 따라 프록시 서버를 실행한다.

### **DNS 서버 요청 과정에서 캐시의 역할은 무엇이며, 어떻게 관리되나요?**

**캐시 역할**

- DNS 서버에 자주 방문하는 도메인을 캐시에 저장한다. 이후 해당 도메인을 요청하면 캐시에 있는 정보를 바로 가져와 응답하기에 응답 속도를 크게 향상 시킬 수 있다.
- 잦은 요청은 서버에 쉽게 과부하가 걸려 작동을 중단시킬 수 있다. 이는 캐시를 사용하여 요청 횟수를 줄여 네트워크 트래픅을 줄이고 서버 부하를 감소할 수 있다.

**캐시 관리**

- 최소 사용 시간(TTL) DNS 서버는 IP 정보에 TTL 값을 설정한다. TTL은 캐시의 유효 시간이며 만료되면 캐시에서 삭제된다.
- 캐시의 저장 공간이 부족하면 DNS 서버는 가장 오랫동안 사용되지 않은 정보부터 삭제한다.
- DNS 서버는 IP주소가 변경되면 갱신한다.

### 브라우저 DNS 캐시와 OS DNS 캐시의 차이는 무엇인가요?

**브라우저 캐시**

- 특정 브라우저에서만 사용가능하며 OS DNS 캐시보다 빠르게 접근할 수 있지만 저장 공간이 적고 유효기간이 짧다.

**OS 캐시**

- 모든 브라우저와 애플리케이션에서 사용되며 브라우저 DNS 캐시보다 느리지만 더 많은 정보를 저장하고 유효기간이 길다.

### DNS 캐시 포이즈닝(중독) 공격이란 무엇이며, 어떻게 방어할 수 있나요?

- 캐시의 정상적인 DNS 레코드를 잘못된 정보로 대체하여 사용자와 디바이스가 잘못된 웹사이트로 연결되도록 하는 악성공격이다.
- 방화벽을 사용하여 공격을 방어 할 수 있다.

### DNS 캐시 플러싱을 수행하는 명령어는 무엇인가요?

DNS 캐시 플러싱은 웹 브라우저 또는 운영체제에서 저장된 DNS 캐시를 삭제하는 작업을 말한다. 이는 웹사이트 접근 문제 해결에 도움이 된다.

**Windows**

- **명령 프롬프트:** `ipconfig /flushdns`
- **PowerShell:** `Clear-DnsClientCache`

### DNS over HTTPS(DoH)가 기존 DNS 시스템과 어떻게 다른가요?

DoH는 CDN을 사용하여 DNS 쿼리 성능을 향상 시킬 수 있다.

DoH는 기존 DNS 시스템보다 보안성이 높고 개인 정보 보호를 강화 하지만, 호환성 문제와 설정이 필요하다는 단점도 있다.

### **디스플레이 none과 비지빌리티 hidden 속성이 렌더링에 미치는 영향은 무엇인가요?**

display: noen은 요소를 렌더 트리에서 제거하여 레이아웃 공간을 차지 하지 않고 숨기는데 사용한다.

visibility: hidden은 요소의 투명하게 하여 안보이게 한것이지 없는 것이 아님으로 렌더 트리에 남아 레이아웃 공간을 차지한다.

### 레이아웃 리플로우가 발생하는 경우와 그 영향은 무엇인가요?

레이아웃 리플로우가 발생하는 경우는 요소의 크기, 형태, 위치가 바뀌는 등 레이아웃을 다시 잡아야 할 때 발생한다.

이 작업은 비용이 많이 들며 렌더링의 시간을 지연 시킬 수 있다.

### CSSOM이란 무엇이며, DOM과 어떻게 다른가요?

CSSOM은 CSS를 파싱한 트리 구조의 객체로 DOM은 HTML을 파싱한 결과물이다.

또한 CSSOM은 style을 하샹식 구조를 띈 트리구조 이다. 

### 페이지 성능 최적화를 위해 디스플레이 none과 비지빌리티 hidden 중 어떤 속성을 사용하는 것이 더 나은가요?

페이지 성능을 최적화 하기 위해서는 display:none이 visibility:hidden보다 일반적으로 성능이 좋다.

display:none은 렌더 트리에 요소가 포함되지 않기 때문에 레이아웃을 잡지 않아도 되며 이를 응용하여 스타일을 block하기 전에 변경하여 성능을 향상 시킬 수 있다

visibility:hidden은 렌더 트리에 요소가 포함되기 때문에 레이아웃 공간을 차지하고 리소스를 로드한다

**하지만 애니메이션을 작성할 때는 visibility:hidden**이 더 효과 적일 수 있다. 

### GPU 가속을 사용하는 CSS 속성은 무엇이 있나요?

GPU 가속이란 

CPU가 아닌 GPU를 사용하여 컴퓨팅 작업 속도를 높이는 기술이다

→ GPU는 CPU보다 더 많은 코어수와 빠른 속도로 작업을 처리 할 수 있으며 에너지 효율이 높기 때문이다

GPU 가속을 사용하는 CSS 속성으로 대표적인 것은 transform, translate, animation, transition, opacity, will-change가 있다.

### **자바스크립트 스크립트 태그에 async와 defer 속성을 사용하는 목적은 무엇이며, 어떤 차이가 있나요?**

- 비동기 자바스크립트인 async와 defer을 사용하는 방법이 있다.
- async는 파싱을 HTML 파싱과  병렬적으로 진행하다 자바스크립트 파싱이 완료되면 HTML파싱을 멈추고 자바스크립트를 실행한다.
- defer은 파싱을 HTML 파싱과 병렬적으로 진행하지만 자바스크립트의 파싱이 완료되어도 HTML파싱은 멈추지 않고 HTML 파싱이 모두 끝났을 때 자바스크립트를 실행한다.

### async와 defer 속성이 없는 경우, 스크립트 로딩과 실행은 어떻게 처리되나요?

- 자바스크립트는 HTML의 파싱을 멈추고 자바스크립트 엔진에서 자바스크립트 파싱을 진행한다
- HTML파싱을 멈추기 때문에 DOM이 다 형성이 된 후인 body태그 위에 선언하는 것이 좋다.

### HTML 파싱 중 스크립트 로딩이 블로킹되는 문제를 해결하기 위한 다른 방법은 무엇이 있나요?

- 비동기 자바스크립트인 async와 defer을 사용하는 방법이 있다.
- async는 파싱을 HTML 파싱과  병렬적으로 진행하다 자바스크립트 파싱이 완료되면 HTML파싱을 멈추고 자바스크립트를 실행한다.
- defer은 파싱을 HTML 파싱과 병렬적으로 진행하지만 자바스크립트의 파싱이 완료되어도 HTML파싱은 멈추지 않고 HTML 파싱이 모두 끝났을 때 자바스크립트를 실행한다.

### 동적으로 스크립트를 로딩하는 방법과 그 장단점은 무엇인가요?

동적으로 스크립트를 로딩하는 방법은 createElement로 스크립트 태그를 생성하고 appendChild로 DOM을 조작하여 사용할 수 있다.

**장점**

- 스크립트를 필요할 때만 로드하여 초기 페이지 로딩 시간을 줄일 수 있다.
- 필요에 따라서 사용하여 사용자 경험을 높일 수 있다.

**단점**

- 추가적으로 HTTP요청이 발생하여 네트워크 오버헤드가 발생할 수 있다.
    - 네트워크 오버헤드란 데이터를 전송하고 처리하기 위해 추가적으로 필요한 추가 데이터 양을 말한다.
- 로드 순서를 제대로 관리하지 않으면 의존성 문제가 생긴다.
- 사용자와 페이지 상호작용시 지연이 발생할 수 있다.

### 크리티컬 렌더링 패스와 자바스크립트 로딩 전략의 관계를 설명해주세요.

크리티컬 렌더링 패스랑 브라우저에서 처음으로 페이지를 표시하기 위해 수행해야 하는 작업의 순서를 의민한다.

로딩 전략으로는 **비동기 자바스크립트, 모듙 번들링, 미디어 유형과 쿼리, 리소스 우선순위** 등이 있다.