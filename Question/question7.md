### **함수형 프로그래밍에서 순수 함수의 중요성은 무엇이며, 어떻게 부작용을 최소화할 수 있는가?**

- 순수 함수는 같은 입력에 대해서 항상 같은 결과를 반환하기 때문에 예측이 가능하다. 이는 예측이 가능하며 디버깅을 쉽게 한다.
- 순수 함수는 외부의 상태에 의존하지 않아 상태를 변경 시키지 않으며, 부작용이 없어 코드의 안정성을 높이고 테스트에 용이하다.
- 즉 불변성을 이용하여 순수 함수는 부작용을 최소화할 수 있다.

### 순수 함수를 구현할 때 고려해야 할 사항은 무엇인가?

- 외부의 상태에 의존하고 있는가
- 단일 기능을 통하여 재 사용성을 높였는가
- 같은 입력에 항상 동일한 결과를 반환하는가
- 사이드 이펙트가 없는가
- 가변 데이터 구조를 사용하지 않고 있는가

### 부작용이 있는 함수와 없는 함수의 예시를 들어 설명하시오.

```jsx
let count = 1;

function countPlus() {
  setTimeOut(() => {
    console.log(count++);
  }, 1000);
}

countPlus();
```

```jsx
let count = 1;

function countPlus(tmpCount, time) {
  setTimeOut(() => {
    console.log(tmpCount++);
  }, time);
}

countPlus(count, 1000);
```

- 외부 상태를 변화 시키지 않으며 재 사용성을 증가 시켰다.

### 함수형 프로그래밍에서 부작용을 관리하는 기법에는 어떤 것들이 있는가?

- 불변한 데이터 구조를 갖도록 새로운 데이터 구조를 생성하거나 반환하여야 한다.
- 순수 함수를 통하여 외부의 상태를 변화 시키지 않아 사이드 이펙트를 줄여야 한다.

### **자바스크립트에서 프로토타입 기반 상속과 클래스 기반 상속의 차이점은 무엇인가?**

- 클래스는 super를 통해 상위 생성자 함수의 메서드와 프로퍼티에 접근이 가능하지만 프로토타입은 super가 없다.
- 클래스는 extends를 사용하여 상속을 사용하지만 프로토타입은 object.create()또는 직접 연결을 통하여 상속을 진행한다.
- 클래스는 상속을 하였을 때 프로토타입의 메서드가 생성자 함수를 바라보지만 프로토타입은 프로토타입의 메서드가 생성자 함수를 바라보도록 따로 한번 더 설정 해주어야 한다.

### 프로토타입 체인이란 무엇이며, 어떻게 작동하는가?

- 생성자 함수를 통하여 생성된 인스턴스가 프로퍼티(메서드)를 찾을 때 자신에게 존재하지 않다면 상위 프로토타입으로 찾아나가다 object 프로토타입까지 존재하지 않는다면 null을 반환한다.

### 클래스 기반 상속을 사용할 때의 장단점은 무엇인가?

**장점**

- 부모 클래스의 코드를 재사용할 수 있다.
- static 키워드를 이용하여 캡슐화를 진행 할 수 있다.

**단점**

- 클래스간의 강력한 결합이 형성되어 유연성을 감소시킬 수 있다.

### 자바스크립트에서 클래스를 어떻게 구현하며, 이 때 주의해야 할 점은 무엇인가?

- 클래스 선언은 호이스팅이 되지 않는다.
- 클래스의 메서드는 기본적으로 프로토타입에 바인딩 된다. 때문에 클래스의 인스턴스를 생성 할 때마다 메모리에 메서드가 별도로 생성되지 않는다.
- 클래스의 내부의 this는 강력한 모드로 작동한다.

### **자바스크립트의 비동기 처리 모델에서 프로미스(Promise)와 async/await의 차이점은 무엇인가?**

- 프로미스는 비동기 처리의 상태를 나타내는 객체이다
- async/await은 비동기 처리를 동기적으로 보일 수 있도록 하는 함수이다.

### 프로미스 체이닝과 async/await을 사용한 비동기 처리의 예시를 들어 설명하시오.

```
function fetchGetData(url) {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error('네트워크 오류 발생');
        }

        return response.json();
      })
      .then(data => resolve(data))
      .catch(error => reject(error));
  })
}

const userGetData = fetchGetData('url')

userGetData
  .then(userData => {
    console.log('사용자 데이터:', userData);
  })
  .catch(error => {
    console.error('에러 발생:', error);
  })
```

```
async function asyncGetFetchData(url) {
  try {
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error('네트워크 오류 발생');
    }

    const data = await response.json();

    return data
  } catch (error) {
    console.error('에러 발생:', error);

    return undefined;
  }
}

async function getUserData() {
  const url = 'url';
  const userData = await asyncGetFetchData(url);

  if(userData !== undefined) {
    console.log('사용자 데이터:', userData);
  }
}

getUserData()
```

- 프로미스는 후속 처리 메서드를 이용하여 비동기 처리를 진행하였고 async/await는 네트워크를 호출할 때 try…catch문을 통하여 진행하였다.

### 프로미스에서 에러 핸들링은 어떻게 하는가?

- 비동기 처리가 실패하여 오류가 발생하였다면 reject함수를 통해 오류와 상태가 rejected인 프로미스 객체가 반환된다.
- 반환된 프로미스를 후속처리 메서드인 catch또는 then의 두 번째 인자를 통해 에러를 핸들링 할 수 있다.

### async/await을 사용할 때의 에러 핸들링 방법은 무엇인가?

- async/await을 사용할 때 에러 핸들링은 try…catch문을 이용하여 에러를 잡을 수 있다. 이는 프로미스를 사용할 때와의 차이점이다.

### **브라우저 랜더링 과정에서 Critical Rendering Path의 개념과 최적화 방법은 무엇인가?**

- Critical Rendering Path의 개념은 브라우저가 페이지를 초기 출력을 위해 실행해야 하는 순서를 의미한다.
- 최적화 방법
  - 미디어 쿼리를 통해 CSS의 렌더링을 비차단 리소스로 표시한다.
  - 비동기 자바스크립트를 이용하여 HTML과 파싱을 동시에 진행한다.
  - 리소스 우선순위를 지정한다.

### Critical Rendering Path를 최적화하는 과정에서 사용할 수 있는 CSS와 JavaScript의 기법은 무엇인가?

- transform을 이용하여 리플로우와 리페인트가 발생하지 않고 하나의 layer를 다시 만들어 컴포지트 단계에서 진행되도록 할 수 있다.
- display가 none이라면 block으로 바꾸기 전에 미리 변경을 진행한 후 block으로 변경한다.
- 애니메이션을 작성할 때 position이 relative라면 주변 노드의 레이아웃에 영향을 줄 수 있기 때문에 absolute로 변경해준다.
- JavaScript에서 리플로우가 발생하는 코드를 한 곳에 모아서 실행시킨다. 이는 렌더 큐가 존재하여 리플로우를 동작사키기 때문이다.

### 웹 페이지 로딩 성능을 개선하기 위한 리소스 로딩 전략에는 어떤 것들이 있는가?

리소스 우선순위를 지정할 수 있다.

1. preload
   1. 현재 페이지에서 사용될 것이 확실한 리소스를 preload해야 한다. 브라우저는 현재 페이지에 필요한 리소스를 빠르게 가져오게 한다.
   2. as를 같이 사용하여 리소스 유형을 브라우저에 알려줘야한다. 올바른 유형을 설정하지 않는다면 브라우저는 해당 리소스를 사용하지 않는다.
   3. preload는 반드시 리소스를 가지고온다 이때 리소스를 중복 참조하여 중복된 개수만큼 리소스를 가져오기 때문에 리소스를 중복해서 참조하지 않아야한다.
   4. 즉 반드시 사용되어야하는 리소스에만 사용한다.
   - 폰트를 가지고 오거나 초기 렌더링에 반드시 필요한 리소스에 사용한다.
2. preconnet
   1. 현재 페이지에서 외부 도메인의 리소스를 참고하는 것을 브라우저에게 알려 미리 외부 도메인과 연결을 설정할 수 있게 한다.
   2. 브라우저가 빨리 닫힐 수 있는 페이지에는 preconnect를 사용하지 않는 것이 좋다.
   - 정확한 경로를 알 수 없을 때 연결을 미리 하여 연결에 필요한 시간을 절약할 수 있고 스트리밍 데이터를 처리할 때 사용한다.
3. prefetch
   1. 미래에 사용될 것이라고 예상되는 리소스들을 가져와 캐시에 저장한다.
   2. 재귀적으로 동작하지 않는다. 즉 HTML 리소스를 가져올 수 있지만 HTML에서 사용되는 CSS등의 리소스는 가져오지 않는다.
   3. Override목적으로 사용하지 않는다

### 브라우저의 레이아웃 리플로우와 리페인트가 성능에 미치는 영향은 무엇인가?

- 리플로우는 박스 모델의 레이아웃을 변경할 때 즉 요소의 위치, 크기, 구조등 변경으로 인해 주변 요소에도 영향을 미칠 수 있다. 때문에 비용이 많이 차지 된다.
- 리페인트는 배경색이나 텍스트 색상이 변경될 때 발생한다. 자주 발생한다면 성능에 악영향을 줄 수 있다.

### **자바스크립트에서 모듈 패턴을 사용하는 이유는 무엇이며, 어떤 방식으로 구현할 수 있는가?**

- 자바스크립트를 script를 이용한다면 모든 파일이 하나의 파일로 전역을 공유되기 때문에 네임스페이스에서 문제를 줄 수 있고 예상치 못한 오류를 발생 시킬 수 있다. 때문에 이를 극복하기 위하여 모듈을 진행한다.

### 모듈 패턴을 사용할 때의 장단점은 무엇인가?

- 모듈 패턴을 사용하였을 때 장점은 캡슐화를 통해 네임스페이스에서 충돌을 방지하고 내부 구현을 은닉할 수 있다. 또한 재사용성을 증가시키고 의존성을 명확하게 파악할 수 있다.
- 단점은 새로운 인스턴스를 생성하여 메모리를 차지 할 수 있고 의존성을 명확하게 관리하지 못한다면 테스트를 어렵게 할 수 있다.

### CommonJS와 ES6 모듈 시스템의 차이점은 무엇인가?

- CommonJS는 동기적으로 모듈을 로드하지만 ES6는 비동기적으로 모듈을 로드한다.
- CommonJS는 require()로 가져오고 module.exports또는 exports를 통해 내보내지만 ES6는 import로 가져오고 export로 내보낸다.

### 웹팩(Webpack)과 같은 모듈 번들러의 역할은 무엇이며, 어떻게 사용하는가?

웹팩은 여러 모듈과 리소스를 하나로 묶어서 최적화된 형태로 변환하는 역할을 한다.
