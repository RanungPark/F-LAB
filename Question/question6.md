### **브라우저 렌더링 과정을 상세히 설명하고, 이 과정에서 성능을 최적화할 수 있는 방법을 제시해주세요.**

- 브라우저 엔진에서 HTML파일을 파싱한다.
- 파싱도중 link태그를 만난다면 CSS파일을 파싱하고 HTML 파싱을 잠시 멈춘다
- CSS파일을 파싱하여 CSSOM트리를 만들었다면 다시 HTML 파일을 파싱한다.
- HTML 파싱으로 생성된 DOM트리와 CSSOM트리를 합쳐 렌더트리를 만든다.
- HTML파싱 도중(body 종료태그 위에서) script를 만난다면 자바스크립트 파일을 브라우저 엔진이 아닌 자바스크립트 파일로 파싱한다.
- 자바스크립트를 바이트코드로 변환하여 읽어들여 렌더 트리에 적용한다
- 이때 사이즈 조절 등 변화를 이르키는 리플로우를 진행한다.
- 리플로우 되었다면 리패인트를 통해 다시 화면에 띄운다.(리플로우될 게 없다면 리페인트만 진행될 수도 있음)
- script태크를 body중간에 놓는다면 생성되지 못한 DOM을 리플로우할 수 있어 오류가 발생할 수 도있다. 때문에 body 종료태그 바로 위에 작성하는 것이 좋다.

### DOM 트리와 CSSOM 트리가 렌더 트리로 합쳐지는 과정을 설명해주세요.

- HTML 파일을 파싱하여 DOM트리를 구축한다.
- CSS파일을 파싱하여 CSSOM트리를 구축한다.
- DOM트리의 루트에서 시작하여 화면에 표시되는 노드 각각 탐색한다.
- 화면에 표시되지 않는 일부 노드들은 렌더 트리에 반영하지 않는다.
- CSS에 의해 화면에 숨겨지는 노드들은 렌더 트리에 반영되지 않는다.
- 화면에 표시되는 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용한다
- 화면에 표시되는 노드를 콘텐츠 및 계산된 스타일과 함께 내보낸다

### 레이아웃(reflow)과 페인트(repaint) 과정에서 성능을 최적화하는 방법은 무엇인가요?

**리플로우(Reflow/Layout)**

- 리플로우는 화면 구조가 변경될 때, 뷰포트 내에 렌더 트리의 노드의 정확한 위치와 크기를 계산하는 과정이다.
  - 최적화
  1. 스타일을 변경할 경우 가장 하위 노드의 클래스를 변경한다.
  2. 인라인 스타일을 사용하지 않는다.
  3. 애니메이션이 있는 노드는 `position`을 `fixed` 또는 `absolute`로 지정한다.
  4. 퀄리티, 퍼포먼스의 타협점을 찾는다.
  5. `<table>` 레이아웃을 피한다.
  6. IE의 CSS 표현식을 사용하지 않는다.
  7. CSS 하위 선택자를 최소화한다.
  8. 숨겨진 노드의 스타일을 변경한다.
  9. 클래스를 혹은 `cssText` 사용하여 한 번에 스타일을 변경한다.
  10. DOM 사용을 최소화한다.
  11. 캐시를 활용한다.

**리페인트(Repaint/Redraw)**

- 리페인트란 화면에 변화가 있을 때 화면을 그리는 과정이다
- 화면의 구조가 변경될 때는 리플로우 과정을 거쳐 화면 구조를 다시 계산후 리페인트를 진행하는데 화면 구조 변화가 없다면 리페인트만 진행된다.
  - 최적화
  1. 화면 변경을 최소화 하기….

### 크리티컬 렌더링 패스는 무엇이며, 이를 최적화하는 방법은 무엇인가요?

- 크리티컬 렌더링 패스는 브라우저가 페이지의 초기 출력을 위해 실행해야 하는 순서를 의미한다
  1. DOM 트리 구축
  2. CSSOM 트리 구축
  3. JavaScript 실행
  4. 렌더 트리 구축
  5. 레이아웃 생성
  6. 페인팅
- 크리티컬 렌더링 패스의 성능을 최적화 한다는 것은 초기 화면을 빠르게 출력한다는 것을 의미한다

1. CSS는 렌더링 차단 리소스이기 때문에 최초 렌더링에 걸리는 시간을 최적화 하려면 CSS를 간단하게 만들고 클라이언에 최대한 빠르게 다운되게 하여야한다.
   1. 미디어 유형과 미디어 쿼리를 사용하면 일부 CSS 리소스를 렌더링 비차단 리소스로 표시할 수 있다
2. 자바스크립트는 파서 차단 리소스이다. 때문에 DOM생성을 차단하고 페이지 렌더링을 지연시키게 된다.
   1. 최적화하기 위해서 자바스크립트를 비동기로 설정하고 불필요한 자바스크립트를 제거해야 한다.
   2. script 태그의 뒷부분에서 정의된 어떠한 태그들은 아직 생성되지 않았기 때문에 노드를 찾을 수 없으며 DOM생성을 차단한다. 때문에 body 태그 닫기 직전에 script 태그를 선언하는 것이 좋다.
   3. 비동기 자바스크립트인 async나 defer을 이용하여 파싱을 중단하지 않는다.
3. 리소스 우선순위 지정하기
4. Critical Rendering Path 측정하기

### 자바스크립트 실행이 브라우저 렌더링에 미치는 영향에 대해 설명해주세요.

- 자바스크립트는 파서 차단 리소스이다
- 브라우저는 HTML을 파싱하다가 자바스크립트를 만나면 진행하던 파싱을 중단한고 자바스크립트 리소스를 다운로드해 파싱하고 실행한다.
- sctipt만 사용한다면 기본적으로 스크립트를 가져와 실행이 끝나면 HTML파싱이 중단되어 화면에 출력되는 시간이 길어지며, DOM이 형성되지 않은 부분을 변화를 주는 코드가 있다면 예상치 못한 오류가 발생 할 수 있다.

1. body태그 위에 작성하는 방법으로 해결할 수 있다
2. async 속성을 사용하여 해결한다.
   1. async속성은 HTML파싱을 멈추지 않고 스크립트를 다운한다. 스크립트 리소스 다운이 완료되면 HTML 파싱을 중단하고 스크립트를 실행한다
3. defer 속성을 사용하여 해결한다.
   1. defer속성 또한 async와 마찬가지로 HTML파싱을 멈추지 않고 스크립트를 다운하지만 HTML파싱이 완료되면 스크립트가 실행된다.

- async는 HTML파일에 종속성이 없을 경우 사용하면 좋다.
- defer은 반대로 종속성이 있는 경우에 사용하면 좋다.

### 웹 페이지 로딩 성능을 개선하기 위한 리소스 로딩 전략은 무엇인가요?

- link 태그의 리소스 우선순위를 지정한다.

1. preload
   1. 현재 페이지에서 사용될 것이 확실한 리소스를 preload해야 한다. 브라우저는 현재 페이지에 필요한 리소스를 빠르게 가져오게 한다.
   2. as를 같이 사용하여 리소스 유형을 브라우저에 알려줘야한다. 올바른 유형을 설정하지 않는다면 브라우저는 해당 리소스를 사용하지 않는다.
   3. preload는 반드시 리소스를 가지고온다 이때 리소스를 중복 참조하여 중복된 개수만큼 리소스를 가져오기 때문에 리소스를 중복해서 참조하지 않아야한다.
   4. 즉 반드시 사용되어야하는 리소스에만 사용한다.
   - 폰트를 가지고 오거나 초기 렌더링에 반드시 필요한 리소스에 사용한다.
2. preconnet
   1. 현재 페이지에서 외부 도메인의 리소스를 참고하는 것을 브라우저에게 알려 미리 외부 도메인과 연결을 설정할 수 있게 한다.
   2. 브라우저가 빨리 닫힐 수 있는 페이지에는 preconnect를 사용하지 않는 것이 좋다.
   - 정확한 경로를 알 수 없을 때 연결을 미리 하여 연결에 필요한 시간을 절약할 수 있고 스트리밍 데이터를 처리할 때 사용한다.
3. prefetch
   1. 미래에 사용될 것이라고 예상되는 리소스들을 가져와 캐시에 저장한다.
   2. 재귀적으로 동작하지 않는다. 즉 HTML 리소스를 가져올 수 있지만 HTML에서 사용되는 CSS등의 리소스는 가져오지 않는다.
   3. Override목적으로 사용하지 않는
