### 자바스크립트로 만든 애니메이션과 CSS로 만든 애니메이션은 어떤 차이가 있을까요?

**성능**: 일반적으로 CSS 애니메이션이 더 효율적이다. 브라우저는 CSS 애니메이션을 하드웨어 가속을 사용하여 처리할 수 있으며, 이는 부드럽고 효율적인 애니메이션을 제공한다. 반면 자바스크립트 애니메이션은 브라우저의 스레드를 차지하고 자바스크립트 엔진의 처리 속도에 따라 성능이 달라질 수 있다.

**구현**: CSS 애니메이션은 비교적 간단하게 구현할 수 있다. 특정 CSS 속성과 애니메이션 지속 시간만 지정하면 된다. 자바스크립트로 애니메이션을 구현하는 경우에는 애니메이션의 세부적인 동작을 프로그래밍해야 하므로 구현이 더 복잡할 수 있다.

**유연성**: 자바스크립트로 만든 애니메이션은 더 많은 유연성을 제공한다. 조건부로 애니메이션을 실행하거나, 애니메이션 중간에 동적으로 속성을 변경하는 등의 작업을 더 쉽게 수행할 수 있다. 반면 CSS 애니메이션은 정적인 성격이 강하며, 더 복잡한 동작을 구현하기 어렵다.

**브라우저 호환성**: 일반적으로 CSS 애니메이션은 브라우저 호환성이 더 좋다. 자바스크립트 애니메이션은 브라우저의 자바스크립트 엔진에 따라 지원 여부가 달라질 수 있다.

### 애니메이션을 구현할 때 성능을 개선할 수 있는 방법에는 어떤 게 있을까요?

- **GPU가속 활용하기**: CSS 속성인 transform과 opacity를 사용하여 요소의 애니메이션을 구현할 때 하드웨어 가속을 활용할 수 있다. 이를 통해 GPU를 사용하여 부드럽고 효율적인 애니메이션을 구현할 수 있다.
- **requestAnimationFrame 사용**: 자바스크립트의 requestAnimationFrame 함수를 사용하여 애니메이션을 구현할 때 브라우저의 리플로우와 리페인트를 최적화할 수 있다.
- **쓰로틀링과 디바운싱**: 애니메이션 이벤트를 쓰로틀링하거나 디바운싱하여 애니메이션의 실행 주기를 제어하고 성능을 향상시킬 수 있다.
- **레이아웃 리플로우 최소화**: 애니메이션을 적용하는 요소의 레이아웃 변경을 최소화하여 브라우저의 리플로우를 최적화 한다.
- **position:absolute 이용**: position이 relative라면 주변 요소의 레이아웃에 영향을 주기 때문에 absolute로 변환하여 이용한다.

### GPU 가속을 하기 위해서 어떻게 해야 되죠?

- GPU가속 대상인 transform, opacity, filter, 애니메이션, z-index, `<video>`또는 `<canvas>`를 활용한다.
- CSS 3D 변환을 이용한 translate3d, translateZ을 사용하여 3D공간에 배치하고 회전시킬 수 있다.

→ 이 레이어 핵은 심각한 성능저하를 불러올 수 있기에 will-change속성으로 대체하다

- will-change속성을 사용하여 요소의 변화를 브라우저에 미리 알리고 하드웨어 가속을 적용할 수 있다.

### **자바스크립트와 CSS를 사용한 애니메이션 구현 시, 각각의 성능 최적화 기법은 무엇이며, 어떤 상황에서 각각을 선택하는 것이 바람직한가?**

**자바스크립트 애니메이션**

- **장점:**
    - 높은 유연성과 동적 제어 가능
    - 복잡한 애니메이션 구현 가능
    - 사용자 상호 작용과 연동 가능
- **단점:**
    - CSS 애니메이션보다 성능 저하 가능성이 높음
    - 자바스크립트 엔진에 의존
    - 브라우저 호환성 문제 발생 가능성
- **성능 최적화 기법:**
    - **요청 최소화:** 애니메이션 라이브러리 사용 최소화, 필요한 기능만 로드
    - **애니메이션 프레임 제어:** `requestAnimationFrame` 사용, 프레임 속도 조절
    - **GPU 활용:** `Canvas` API 사용, WebGL 활용
    - **DOM 조작 최소화:** 직접적인 DOM 조작 줄이고 가상 DOM 활용
    - **코드 최적화:** 불필요한 코드 제거, 변수 사용 최소화

**CSS 애니메이션**

- **장점:**
    - 자바스크립트보다 성능 우수
    - 브라우저 기본 기능 활용
    - 코드 작성량 감소
- **단점:**
    - 자바스크립트보다 유연성 낮음
    - 복잡한 애니메이션 구현 어려움
    - 사용자 상호 작용 연동 제한적
- **성능 최적화 기법:**
    - **애니메이션 속성 최소화:** 사용하지 않는 속성 제거
    - **키프레임 최적화:** 불필요한 키프레임 제거, 단계별 애니메이션 활용
    - **하드웨어 가속 활용:** `transform` 속성 사용, `will-change` 속성 활용
    - **애니메이션 범위 제한:** 애니메이션 적용 범위 최소화
    - **CSS 컴포넌트 활용:** 재사용 가능한 컴포넌트로 애니메이션 구현

### GPU 가속이 가능한 CSS 속성은 구체적으로 어떤 것들이 있나요?

- CSS 3D Transform(translate3d, preserve-3d 등)이나 perspective 속성이 적용된 경우
- `<video>` 또는 `<canvas>` 요소
- CSS3 애니메이션함수나 CSS 필터 함수를 사용하는 경우
- 자식 요소가 레이어로 구성된 경우
- z-index 값이 낮은 형제 요소가 레이어로 구성된 경우. 레이어로 구성된 요소의 위에 위치하면 해당 요소도 레이어로 구성된다.

### will-change 속성을 사용할 때 주의해야 할 점은 무엇인가요?

- **남용하지 마라**: will-change 속성은 필요한 요소에만 적용하여 필요한 최적화를 수행하는 것이 좋다. 너무 많은 요소에 will-change 속성을 적용하면 메모리 사용량이 증가하고 브라우저 성능에 부정적인 영향을 미칠 수 있다.
- **불필요한 최적화를 피하라**: will-change속성을 사용하면 브라우저는 요소의 변경을 예상하고 최적화를 수행한다. 그러나 변경이 실제로 발생하지 않는 경우에도 리소스를 사용하여 최적화를 수행할 수 있다. 따라서 will-change 속성은 변경이 예상되는 요소에만 적용해야 한다.
- **브라우저에 작업할 충분한 시간을 제공하라**: will-change는 변경 사항이 발생 중인 것이 아니라 발생할 변경 사항에 대해 브라우저에 알리기 위함이다. 이러한 최적화를 실제로 수행하기 위해서는 브라우저가 약간의 시간이 필요하다.
- **사용후 제거하라**: will-change 속성은 브라우저의 리소스를 많이 차지한다. 따라서 해당 요소가 변경되지 않거나 변경이 더 이상 필요하지 않을 때 속성을 제거하는 것은 불필요한 리소스 소모를 줄이고 브라우저 성능을 개선하는 데 도움이 된다.

### 자바스크립트 애니메이션에서 requestAnimationFrame을 사용하는 이유와 그 효과는 무엇인가요?

- **부드러운 애니메이션**: requestAnimationFrame은 브라우저의 프레임 재생 주기에 맞춰 애니메이션 함수를 호출한다. 이는 setInterval과 같은 다른 방법 보다 더 부드러운 애니메이션을 만들 수 있도록 한다.
- **성능 향상**: requestAnimationFrame은 브라우저가 화면을 갱신할 준비가 되면 애니메이션 함수를 호출한다. 이는 CPU 사용량을 줄이고 성능을 향상시킬 수 있다
- **정확한 타이밍**: requestAnimationFrame은 애니메이션 프레임의 시작 시간을 정확하게 제공한다. 이는 프레임 간 일관성을 유지하고 더 정교한 애니메이션을 만들 수 있다.

### 크로스 브라우징 이슈를 해결하기 위한 바벨과 폴리필의 구체적인 사용 방법은?

- **바벨**: 바벨은 최신 JavaScript 문법을 오래된 브라우저에서 호환될 수 있도록 변환하는 도구이다. 바벨을 사용하면 ES6, ES7, ES8 등 최신 JavaScript 기능을 사용하여 코드를 작성할 수 있으며, 바벨이 코드를 자동으로 변환하여 오래된 브라우저에서도 작동하도록 한다.(스프레드 연산자등)
- **폴리필**: 폴리필은 특정 브라우저에서 지원되지 않는 기능을 구현하는 JavaScript 코드이다. 폴리필을 사용하면 해당 기능을 지원하지 않는 브라우저에서도 기능을 사용할 수 있도록 한다. (프로미스 등)

### 프로그레시브 인핸스먼트와 그레이스풀 디그레이데이션을 구현하는 구체적인 방법은 무엇인가요?

**프로그레시브 인핸스먼트:**점진적 현장 progressive-enhancement

**기본 기능**부터 구현하여 모든 사용자에게 기본적인 기능을 제공하고, **점진적으로** JavaScript, CSS, 웹 API 등을 사용하여 기능을 추가하고 디자인을 향상시킨다.

**구현 방법:**

- **HTML 코드에서 기본 기능 구현:** 모든 사용자가 접근할 수 있도록 HTML 코드에서 기본적인 기능과 콘텐츠를 구현한다.
- **JavaScript 및 CSS 사용하여 기능 추가:** JavaScript와 CSS를 사용하여 기본 기능을 확장하고 디자인을 향상시킨다.
- **모바일 장치 및 저사양 브라우저 고려:** 모바일 장치 및 저사양 브라우저에서도 사용할 수 있도록 코드를 최적화한다.

**2. 그레이스풀 디그레이데이션:**우아한 성능저하 graceful-degradation

**최신 기능**부터 구현하여 최신 브라우저 사용자에게 최상의 경험을 제공하고, **점진적으로** 기능을 제거하거나 대체하여 오래된 브라우저에서도 기본적인 기능을 제공한다.

**구현 방법:**

- **최신 기능부터 구현:** 최신 브라우저에서 사용할 수 있는 최신 기능을 JavaScript, CSS, 웹 API 등을 사용하여 구현한.
- **기능 제거 또는 대체:** 오래된 브라우저에서 지원되지 않는 기능은 제거하거나 대체 기능으로 구현한다.
- **폴리필 사용:** 필요한 경우 폴리필을 사용하여 오래된 브라우저에서 특정 기능을 구현한다.

### **GPU 가속을 사용한 애니메이션 구현 시, 성능 저하를 방지하기 위한 최적화 전략은 무엇인가?**

**레이어 최소화:**

- 애니메이션에 필요한 레이어만 사용한다.
- 불필요한 레이어는 성능 저하의 주요 원인이 될 수 있다.
- 레이어를 컴포넌트로 만들어 재사용 가능하게 한다.

**레이어 크기 줄이기:**

- 레이어 크기가 클수록 GPU 처리 부담이 커진다.
- 이미지 압축, 벡터 그래픽 사용, SVG 또는 Canvas 활용 등을 통해 레이어 크기를 줄인다.

**효율적인 그래픽 기술 사용:**

- SVG 또는 Canvas와 같은 효율적인 그래픽 기술을 사용한다.
- CSS 애니메이션보다 Canvas 애니메이션이 더 효율적일 수 있다.
- WebGL을 사용하여 3D 애니메이션을 구현할 수 있다.

**GPU 작업 분산:**

- 여러 GPU를 사용하거나 애니메이션 작업을 여러 프레임에 분산하여 GPU 부하를 줄인다.
- `requestAnimationFrame` API를 사용하여 프레임 간 애니메이션을 효율적으로 제어한다.

### GPU 메모리 사용량이 과도하게 증가할 때 발생할 수 있는 문제는 무엇인가요?

**성능 저하**: GPU 메모리가 과도하게 사용되면 메모리 대역폭이 부족해지고 애니메이션 및 그래픽 작업의 처리 속도가 느려질 수 있다. 이로 인해 애니메이션의 부드러움이 감소하거나 화면이 버벅거릴 수 있다.

### 레이어의 과다 생성을 방지하기 위한 코드상의 접근 방법은?

**레이어 재사용:**

- 가능한 경우 기존 레이어를 재사용한다.
- 레이어 풀을 사용하여 사용하지 않는 레이어를 관리한다.
- 레이어를 컴포넌트로 만들어 재사용 가능하게 한다.

**레이어 최적화:**

- 레이어 크기 및 복잡성을 최소화한다.
- SVG 또는 Canvas와 같은 효율적인 그래픽 기술을 사용한다.
- 이미지 압축 및 최적화를 사용한다.

### CSS 트랜스폼과 오페시티를 사용할 때 GPU 가속의 이점은 구체적으로 무엇인가요?

**성능 향상:**

- CPU 대신 GPU를 사용하여 애니메이션 및 그래픽 처리를 수행하여 성능을 크게 향상시킬 수 있다.
- 특히, 많은 요소를 애니메이션화하거나 복잡한 그래픽 효과를 구현할 때 효과적이다.
- 프레임 속도가 높아져 부드럽고 자연스러운 애니메이션을 구현할 수 있다.

**배터리 효율 개선:**

- GPU는 CPU보다 에너지 효율적이므로 GPU 가속을 사용하면 배터리 수명을 늘릴 수 있다.
- 특히, 모바일 기기에서 중요한 요소이다.

**메모리 사용량 감소:**

- GPU는 CPU보다 메모리 사용량이 적으므로 GPU 가속을 사용하면 메모리 사용량을 줄일 수 있다.
- 특히, 저사양 기기에 유용하다.

### 브라우저별 GPU 가속 지원 차이를 어떻게 파악하고 대응할 수 있나요?

**지원 차이 파악**

- 다음 사이트를 통해 브라우저별 GPU 가속 지원 차이를 확인할 수 있다.
    - Can I Use: https://caniuse.com/
    - CSS Triggers: https://csstriggers.com/
- 브라우저 개발자 도구를 사용하여 GPU 가속 사용 여부를 확인할 수 있다.

**대응**

**폴리필 사용:**

- 오래된 브라우저에서 GPU 가속 기능을 지원하지 않을 경우 폴리필을 사용하여 지원할 수 있다.
- `web-animations.js`와 같은 폴리필을 사용할 수 있다.

**브라우저별 코드 분기:**

- 브라우저별 지원 기능에 따라 코드를 분기하여 다르게 처리할 수 있다.
- `Modernizr`와 같은 라이브러리를 사용하여 브라우저 기능을 감지하고 코드를 분기할 수 있다.

**최신 브라우저 사용 권장:**

- 최상의 성능과 호환성을 위해 최신 브라우저 사용을 권장한다.
- 사용자에게 최신 브라우저를 업데이트하도록 권장할 수 있다.

### 하드웨어 가속이란?

- 하드웨어 가속이란 CPU가 하는 일을 GPU가 분담하여 처리해서 컴퓨터의 성능을 최대한으로 끌어올리고 브라우저 더링을 보다 빠르게 할 수 있게 만든다.

### 하드웨어 가속의 주의 사항

- 무분별한 하드웨어 가속은 오히려 브라우저를 느리게 한다.
- 요소에 하드웨어 가속 속성이 부여되면 즉시 대상 영역이 GPU에 업로드되며, 이때 업로드되는 영역이 크면 화면이 깜빡이는 현상이 발생될 수 있다.
- 요소에 하드웨어 가속 속성이 부여되면 레이어로 분리되며, 레이어는 변경되는 내용이 없는 한 요소를 GPU 메모리에 다시 업로드하지 않는다.
- 하드웨어 가속 속성을 사용한 요소의 내용이 변경되면 GPU 메모리가 갱신되므로 요소의 내용을 미리 변경한 다음 하드웨어 가속 속성을 부여한다.
- 성능이 낮은 기기에서 하드웨어 가속을 사용하면 오히려 성능 저하를 가져올 수 있다.