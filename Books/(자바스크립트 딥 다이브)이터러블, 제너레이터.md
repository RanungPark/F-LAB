## 이터러블

### 왜 탄생 하였는가?

- ES6 이전의 순회 가능한 데이터 컬레션, 즉 배열, 문자열, 유사 배열, DOM객체 등의 통일된 규약이 없어 각자 나름의 구조를 가지고 for문, for…in문, forEach 메서드 등 다양한 방법으로 순회하였다.

### 이터러블은?

- 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수한는 이터러블로 통일하여 for…of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.

**왜 필요한가?**

- 다양한 자료구조가 하나의 순회 방식을 갖도록 규정한다.

**이터레이션 프로토콜**

- 이터러블 프로토콜
  - Symbol.iterator 프로퍼티 키를 사용하는 메서드로 갖고 있거나 프로토타입 체인을 통해 상속받은 자료구조
  - Symbol.iterator 메서드를 호출하면 이터레이터를 반환한다.
  - 이터러블 프로토콜을 준수한 객체를 이터러블이라한다.
  - 이터러블은 for…of문 으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으러 사용할 수 있다.
- 이터레이터 프로토콜
  - 이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 를 반환한다.
  - 이터레이터는 next메서드를 소유하며 next를 호출하면 이터러블을 순회하여 value와 done프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다.
  - 즉 이터러블의 요소를 탐색하기 위한 포인터 역할을 한다.

## 제너레이터

- 제너레이터 함수는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수 함수이다.
- 제너레이터 함수는 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 함수 시행의 제어권을 양도 할 수 있다.
- 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자에게 상태를 전달 받을 수 있다.
  - yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.
  - 제너레이터 객체의 next 메서드에 전달한 인수는 제너레이터 함수의 yield 표현식을 할당 받는 변수에 할당된다.
- 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 **이터러블**이면서 동시에 **이터레이터인 제너레이터 객체**를 반환한다.
  - 제너레이터 객체의 next를 통해 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환할 수 있다.
  - yield 키워드 뒤에 오는 순서대로 순회가 가능하다.(이터러블을 쉽게 만들 수 있다)

**왜 필요한가?**

- 이터레이터의 next메서드와 제너레이터의 yield 키워드를 통해서 프로미스의 후속 처리 메서드인 then/catch/finally 없이 비동기 처리 결과를 반환하도록 구현할 수 있다.
- 즉 프로미스를 사용한 비동기 처리를 동기 처리처럼 구현할 수 있다.
